{\rtf1\ansi\ansicpg1252\deff0\deflang1046{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sa200\sl276\slmult1\lang22\b\f0\fs22 Se vc tiver escrito aplicativos com Delphi:\par
\b0 - uma classe cont\'e9m dados e c\'f3digo\par
- pode manipular classes em tempo de desing e em tempo de execu\'e7\'e3o.\par
Ent\'e3o vc se tornou um usu\'e1rio componente.\par
\par
\tab Ao criar novos componentes, vc lida com classes de maneira que os desenvolvedores de nunca precisam fazer. Vc oculta o funcionamento interno do componente dos desenvolvedores que o usar\'e3o.\par
- escolhendo ancestrais apropriados para seus componentes, \par
- projetando interfaces que exponham apenas as propriedades e os m\'e9todos que os desenvolvedores precisam\par
- e seguindo outras diretrizes nos t\'f3picos a seguir,  vc pode criar componentes vers\'e1teis e reutilizaveis\par
\par
\b Definindo Novas Classes\b0  \par
\tab A diferenca entre escritores de componentes e desenvolvedores de aplica\'e7\'f5es:  \par
- \'e9 que os escritores de componentes criam novas classes \par
-  desenvolvedores manipulam instancias das classes\par
\tab Uma classe \'e9 essencialmente um tipo.\par
\tab Um programador sempre trabalhar\'e1 com tipos e instancias.  Vc cria uma vari\'e1vel do tipo integer, classes s\'e3o usualmente mais complexas que um simples tipo de dados, por\'e9m se trabalha com a mesma id\'e9ia.\par
- instancias assumem valores do mesmo tipo e pode realizar diferentes tarefas.\par
\tab Ex: \'e9 muito comum criar um form contendo dois buttons, um caption Ok e outro Cancel. Cada um \'e9 uma instancia da classe TButton mas tem valores atribuidos diferentes na propriedade Caption e diferentes manipula\'e7oes no OnClik enventos. \par
\tab H\'e1 duas raz\'f5es para derivar uma nova classe:\par
- Alterando Padr\'f5es de Classe para Evitar Repeti\'e7\'e3o \par
- Adicionando Novos Recursos a uma Classe\par
\tab Em ambos os casos, o objetivo \'e9 criar objetos reutiliz\'e1veis. Se voc\'ea projetar componentes com reutiliza\'e7\'e3o em mente, poder\'e1 salvar o trabalho posteriormente. D\'ea \'e0s suas classes valores padr\'e3o utiliz\'e1veis, mas permita que elas sejam personalizadas.\par
\b\tab Alterando Padr\'f5es de Classe para Evitar Repeti\'e7\'e3o: \b0 marioria dos programadores tentam evitar repeti\'e7\'f5es. Se vc estiver reescrevendo as mesmas linhas de c\'f3digo, por repetidas vezes, coloque o c\'f3digo em uma subrotina ou fun\'e7\'e3o, ou construa uma biblioteca de rotinas que vc possa usar em v\'e1rios programas. O mesmo vale para componentes, se vc estiver alterando as mesmas propriedades ou fazendo as mesmas chamadas de m\'e9todo, poder\'e1 criar um novo componente que faz isso por padr\'e3o.\par
 \tab\b Adicionando Novos Recursos a uma Classe:\b0   Um motivo comum para a cria\'e7\'e3o de novos componentes \'e9 adicionar recursos n\'e3o encontrados em componentes existentes. Quando voc\'ea fizer isso, voc\'ea derivar o novo componente de um componente existente ou uma classe base abstrata, como TComponent ou TControl. Derive seu novo componente da classe que cont\'e9m o subconjunto mais pr\'f3ximo dos recursos que voc\'ea deseja. Voc\'ea pode adicionar recursos a uma classe, mas n\'e3o pode remov\'ea-los; Portanto, se uma classe de componente existente contiver propriedades que voc\'ea n\'e3o deseja incluir na sua, voc\'ea deve derivar do ancestral desse componente. Por exemplo, se voc\'ea quiser adicionar recursos a uma caixa de listagem, poder\'e1 derivar seu componente de TListBox. No entanto, se voc\'ea quiser adicionar novos recursos, mas excluir alguns recursos da caixa de listagem padr\'e3o, precisar\'e1 derivar seu componente do TCustomListBox, o ancestral do TListBox. Em seguida, voc\'ea pode recriar (ou tornar vis\'edveis) apenas os recursos de caixa de listagem desejados e adicionar seus novos recursos.\par
\par
\b Antepassados, Descendentes e Hierarquias de Classe\b0\par
\tab Os desenvolvedores de aplicativos t\'eam como certo que cada controle tem propriedades nomeadas Top e Left, que determinam sua posi\'e7\'e3o no formul\'e1rio. Para eles, pode n\'e3o importar que todos os controles herdam essas propriedades de um ancestral comum, o TControl. Quando voc\'ea cria um componente, no entanto, voc\'ea deve saber de qual classe deriv\'e1-lo, para que ele herde os recursos apropriados. E voc\'ea deve saber tudo o que seu controle herda, para que voc\'ea possa aproveitar os recursos herdados sem recri\'e1-los.\par
\tab A classe da qual voc\'ea deriva um componente \'e9 chamada de ancestral imediato. Cada componente herda de seu ancestral imediato e do ancestral imediato de seu ancestral imediato e assim por diante. Todas as classes das quais um componente herda s\'e3o chamadas de seus ancestrais; o componente \'e9 um descendente de seus ancestrais.\par
\tab Juntos, todos os relacionamentos descendentes-ancestrais em um aplicativo constituem uma hierarquia de classes. Cada gera\'e7\'e3o na hierarquia cont\'e9m mais do que seus ancestrais, j\'e1 que uma classe herda tudo de seus ancestrais, adiciona novas propriedades e m\'e9todos ou redefine os existentes.\par
\tab\ul Se voc\'ea n\'e3o especificar um ancestral imediato, o Delphi deriva seu componente do ancestral padr\'e3o, TObject. TObject \'e9 o \'faltimo ancestral de todas as classes na hierarquia de objetos.\par
\ulnone\tab\ul A regra geral para escolher de qual objeto derivar \'e9 simples: Escolha o objeto que cont\'e9m o m\'e1ximo poss\'edvel do que voc\'ea deseja incluir em seu novo objeto, mas que n\'e3o inclui nada que voc\'ea n\'e3o deseja no novo objeto. Voc\'ea sempre pode adicionar coisas aos seus objetos, mas n\'e3o pode tirar as coisas.\par
\par
\ulnone\b CONTROLE DE ACESSO\b0\par
\tab Existem cinco n\'edveis de controle de acesso - tamb\'e9m chamados de visibilidade:\par
 - em propriedades, \par
- m\'e9todos e \par
- campos. \par
\tab A visibilidade determina qual c\'f3digo pode acessar quais partes da classe. Ao especificar visibilidade, voc\'ea define a interface para seus componentes.\par
A tabela a seguir mostra os n\'edveis de visibilidade, da mais restritiva \'e0 mais acess\'edvel.\par
N\'edveis de visibilidade dentro de um objeto:\ul\par
\ulnone - PRIVATE - o c\'f3digo est\'e1 acessivel na unit onde a classe est\'e1 definida\par
- PROTECTED - o c\'f3digo est\'e1 acessivel na unit onde a classe est\'e1 definida e para seus descendentes\par
- PUBLIC - o c\'f3digo est\'e1 acessivel para todos\par
- AUTOMATED - o c\'f3digo est\'e1 acessivel para todos.\par
- PUBLISHED - o c\'f3digo est\'e1 acess\'edvel para todos e acessivel no Object Inspector.\par
\par
\b Metodos de Despacho\par
\b0\tab Despacho refere-se \'e0 maneira como um programa determina onde um m\'e9todo deve ser chamado quando ele encontra uma chamada de m\'e9todo. O c\'f3digo que chama um m\'e9todo se parece com qualquer outro procedimento ou chamada de fun\'e7\'e3o. Mas as classes t\'eam diferentes maneiras de despachar m\'e9todos.\par
Os tr\'eas tipos de envio de m\'e9todo s\'e3o:\par
- \b Static:\b0  Todos os m\'e9todos s\'e3o est\'e1ticos, a menos que voc\'ea especifique o contr\'e1rio quando os declarar. Os m\'e9todos est\'e1ticos funcionam como procedimentos ou fun\'e7\'f5es regulares. O compilador determina o endere\'e7o exato do m\'e9todo e vincula o m\'e9todo em tempo de compila\'e7\'e3o.  A principal vantagem dos m\'e9todos est\'e1ticos \'e9 que despach\'e1-los \'e9 muito r\'e1pido. Como o compilador pode determinar o endere\'e7o exato do m\'e9todo, ele vincula o m\'e9todo diretamente. Os m\'e9todos virtual e din\'e2mico, por outro lado, usam meios indiretos para pesquisar o endere\'e7o de seus m\'e9todos em tempo de execu\'e7\'e3o, o que leva um pouco mais de tempo. Um m\'e9todo est\'e1tico n\'e3o \'e9 alterado quando herdado por uma classe descendente. Se voc\'ea declarar uma classe que inclua um m\'e9todo est\'e1tico, derivar uma nova classe, a classe derivada compartilha exatamente o mesmo m\'e9todo no mesmo endere\'e7o. Isso significa que voc\'ea n\'e3o pode substituir m\'e9todos est\'e1ticos; um m\'e9todo est\'e1tico sempre faz exatamente a mesma coisa, n\'e3o importa em que classe ele \'e9 chamado. Se voc\'ea declarar um m\'e9todo em uma classe derivada com o mesmo nome de um m\'e9todo est\'e1tico na classe ancestral, o novo m\'e9todo simplesmente substituir\'e1 o herdado no m\'e9todo. classe derivada.\par
- \b Virtual\b0 : Os m\'e9todos virtuais empregam um mecanismo de despacho mais complicado e mais flex\'edvel do que os m\'e9todos est\'e1ticos. Um m\'e9todo virtual pode ser redefinido em classes descendentes, mas ainda assim ser chamado na classe ancestral. O endere\'e7o de um m\'e9todo virtual n\'e3o \'e9 determinado em tempo de compila\'e7\'e3o; em vez disso, o objeto em que o m\'e9todo \'e9 definido procura o endere\'e7o em tempo de execu\'e7\'e3o. Para tornar um m\'e9todo virtual, adicione a diretiva virtual ap\'f3s a declara\'e7\'e3o do m\'e9todo. A diretiva virtual cria uma entrada na tabela de m\'e9todos virtuais do objeto, ou VMT, que cont\'e9m os endere\'e7os de todos os m\'e9todos virtuais em um tipo de objeto. Quando voc\'ea deriva uma nova classe de uma existente, a nova classe obt\'e9m sua pr\'f3pria VMT, que inclui todas as entradas do VMT do ancestral, al\'e9m de quaisquer m\'e9todos virtuais adicionais declarados na nova classe.\par
- \b Dynamic:\b0  M\'e9todos din\'e2micos s\'e3o m\'e9todos virtuais com um mecanismo de despacho ligeiramente diferente. Como os m\'e9todos din\'e2micos n\'e3o possuem entradas na tabela de m\'e9todos virtuais do objeto, eles podem reduzir a quantidade de mem\'f3ria que os objetos consomem. No entanto, o envio de m\'e9todos din\'e2micos \'e9 um pouco mais lento do que despachar m\'e9todos virtuais regulares. Se um m\'e9todo \'e9 chamado com freq\'fc\'eancia, ou se sua execu\'e7\'e3o \'e9 de tempo cr\'edtico, voc\'ea provavelmente deve declar\'e1-lo como virtual em vez de din\'e2mico. Objetos devem armazenar os endere\'e7os de seus m\'e9todos din\'e2micos. Mas, em vez de receber entradas na tabela de m\'e9todos virtuais, os m\'e9todos din\'e2micos s\'e3o listados separadamente. A lista de m\'e9todos din\'e2micos cont\'e9m entradas apenas para m\'e9todos introduzidos ou substitu\'eddos por uma classe espec\'edfica. (A tabela de m\'e9todos virtuais, por outro lado, inclui todos os m\'e9todos virtuais do objeto, herdados e introduzidos.) M\'e9todos din\'e2micos herdados s\'e3o despachados pela pesquisa da lista de m\'e9todos din\'e2micos de cada ancestral, trabalhando para tr\'e1s atrav\'e9s da \'e1rvore de heran\'e7a. Para tornar um m\'e9todo din\'e2mico, adicione a diretiva din\'e2mica ap\'f3s a declara\'e7\'e3o do m\'e9todo.\par
\par
\b Membros de classe abstrata\b0\par
\tab Quando um m\'e9todo \'e9 declarado como abstrato em uma classe ancestral, voc\'ea deve super\'e1-lo (redeclarando e implementando-o) em qualquer componente descendente antes de usar o novo componente nos aplicativos. Na plataforma Win32, o Delphi pode criar inst\'e2ncias de uma classe que cont\'e9m membros abstratos. Isso n\'e3o \'e9 recomendado, no entanto. Para obter mais informa\'e7\'f5es sobre como localizar partes herdadas de classes, consulte Criando propriedades - Vis\'e3o geral e Criando m\'e9todos - Vis\'e3o geral\b\par
\par
Classes e ponteiros\b0\par
\tab Toda classe (e, portanto, todo componente) \'e9 realmente um ponteiro. O compilador automaticamente dereferencia os ponteiros de classe para voc\'ea, ent\'e3o na maioria das vezes voc\'ea n\'e3o precisa pensar sobre isso. O status das classes como ponteiros se torna importante quando voc\'ea passa uma classe como um par\'e2metro. Em geral, voc\'ea deve passar classes por valor e n\'e3o por refer\'eancia. A raz\'e3o \'e9 que as classes j\'e1 s\'e3o ponteiros, que s\'e3o refer\'eancias; passando uma classe por valores de refer\'eancia para passar uma refer\'eancia a uma refer\'eancia.\par
\par
\b As partes b\'e1sicas de um programa orientado a objeto\par
\b0 - o bloco de constru\'e7\'e3o b\'e1sico de um programa OO \'e9 uma classe.\par
- ele define os campos e metodos\par
\tab OO introduziu maneiras mais simples de permitir que os campos fossem vistos externamento \'e0 classe - via PROPERTIES. \par
\tab Mas uma classe \'e9 apenas um conjunto de campos, propriedades e metodos. \par
\tab Criar uma instancia de uma classe \'e9 chamado de instancia\'e7\'e3o e gera um objeto. Cada instancia de uma classe \'e9 um objeto separado.\par
type\par
\tab TSimple = class(TObject)\par
\tab\tab simpleCount : Byte;\par
\tab\tab property count : Byte read simpleCount;\par
\tab\tab procedure SetCount(count : Byte);\par
       \tab end;\par
\b Sobrecarca de m\'e9todos\par
\tab\b0 O mesmo nome pode ser usado para essa rotina. O delphi decide qual rotina chamar pelo numero e tipo de parametros.\par
\b Polimorfismo\par
\tab\b0\'c9 definido como a capacidade de objetos relacionados, mas diferentes, de implementar o m\'e9todo a sua maneira. Ex: em um aplicativo grafico, podemos ter objetos de circulo, quadrado e triangulo, cada um dos quais poderia ter um metodo Draw. Isso seria o mesmo para o chamador, mas cada objeto seria desenhado de uma maneira diferente.\par
\b Abstra\'e7\'e3o \b0\par
\tab Parte fundamental do OO, mesmo que poucas pessoas o usem. Abstra\'e7\'e3o \'e9 quando uma classe define m\'e9todos como esqueletos. N\'e3o fornece o c\'f3digo para execut\'e1-los. Insiste que as classes herdadas a fa\'e7am. A id\'e9ia \'e9 que a classe pai esclare\'e7a para subclasses exatamente quais m\'e9todos eles precisam fornecer para consistencia. \par
\b Interface\par
\tab\b0 S\'e3o ainda menos usadas que a abstra\'e7\'e3o. Eles s\'e3o uma forma especializada de abstra\'e7\'e3o. Uma defini\'e7\'e3o de interface compreende apenas m\'e9todos abstratos. Qualquer classe que implemente uma interface deve implementar esses m\'e9todos abstratos. Uma classe pode implementar mais de uma interface. \b\par
}
 